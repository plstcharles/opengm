diff -urwB FastPD_DemoVersion/block.h FastPD.src-patched/block.h
--- FastPD_DemoVersion/block.h	2003-08-12 00:32:42.000000000 -0400
+++ FastPD.src-patched/block.h	2017-08-14 16:08:17.954141000 -0400
@@ -89,8 +89,8 @@
 	deallocated only when the destructor is called.
 */
 
-#ifndef __BLOCK_H__
-#define __BLOCK_H__
+#ifndef __FAST_PD_BLOCK_H__
+#define __FAST_PD_BLOCK_H__
 
 #include <stdlib.h>
 
@@ -98,6 +98,8 @@
 /***********************************************************************/
 /***********************************************************************/
 
+namespace fastPDLib {
+
 template <class Type> class Block
 {
 public:
@@ -105,10 +107,10 @@
 	   (optionally) the pointer to the function which
 	   will be called if allocation failed; the message
 	   passed to this function is "Not enough memory!" */
-	Block(int size, void (*err_function)(char *) = NULL) { first = last = NULL; block_size = size; error_function = err_function; }
+	Block(int size, void (*err_function)(const char *) = NULL) { first = last = NULL; block_size = size; error_function = err_function; }
 
 	/* Destructor. Deallocates all items added so far */
-	~Block() { while (first) { block *next = first -> next; delete first; first = next; } }
+	~Block() { while (first) { block *next = first -> next; delete[] ((char*)first); first = next; } }
 
 	/* Allocates 'num' consecutive items; returns pointer
 	   to the first item. 'num' cannot be greater than the
@@ -192,7 +194,7 @@
 	block	*scan_current_block;
 	Type	*scan_current_data;
 
-	void	(*error_function)(char *);
+	void	(*error_function)(const char *);
 };
 
 /***********************************************************************/
@@ -206,10 +208,10 @@
 	   (optionally) the pointer to the function which
 	   will be called if allocation failed; the message
 	   passed to this function is "Not enough memory!" */
-	DBlock(int size, void (*err_function)(char *) = NULL) { first = NULL; first_free = NULL; block_size = size; error_function = err_function; }
+	DBlock(int size, void (*err_function)(const char *) = NULL) { first = NULL; first_free = NULL; block_size = size; error_function = err_function; }
 
 	/* Destructor. Deallocates all items added so far */
-	~DBlock() { while (first) { block *next = first -> next; delete first; first = next; } }
+	~DBlock() { while (first) { block *next = first -> next; delete[] ((char*)first); first = next; } }
 
 	/* Allocates one item */
 	Type *New()
@@ -260,9 +262,10 @@
 	block		*first;
 	block_item	*first_free;
 
-	void	(*error_function)(char *);
+	void	(*error_function)(const char *);
 };
 
+}
 
 #endif
 
diff -urwB FastPD_DemoVersion/Fast_PD.h FastPD.src-patched/Fast_PD.h
--- FastPD_DemoVersion/Fast_PD.h	2009-02-24 16:10:46.000000000 -0500
+++ FastPD.src-patched/Fast_PD.h	2017-08-11 20:43:26.000000000 -0400
@@ -13,13 +13,24 @@
 #include <assert.h>
 #include <time.h>
 #include <string.h>
-#include "graph.h"
-#include "common.h"
+#include "opengm/inference/external/fastpd/graph.h"
 
-#define DIST(l0,l1)   (_dist[l1*_numlabels+l0])
-#define UPDATE_BALANCE_VAR0(y,d,h0,h1) { (y)+=(d); (h0)+=(d); (h1)-=d; }
-#define NEW_LABEL(n) ((n)->parent && !((n)->is_sink))
-#define REV(a) ((a)+1)
+#include <inttypes.h>
+
+namespace fastPDLib {
+
+template<typename TReal>
+void UPDATE_BALANCE_VAR0(TReal& y, const TReal& d, TReal& h0, TReal& h1) {
+	y += d; h0 += d; h1 -= d;
+}
+
+inline bool NEW_LABEL(const Graph::node* n) {
+	return n->parent && !(n->is_sink);
+}
+
+inline Graph::arc* REV(Graph::arc* a) {
+	return a+1;
+}
 
 //#############################################################################
 //#
@@ -245,7 +256,7 @@
 					Real delta2;
 					if ( delta1 < 0 || (delta2=delta-delta1) < 0 ) 
 					{
-						UPDATE_BALANCE_VAR0( *cur_y, delta1, cur_h[einfo->tail], cur_h[einfo->head] )
+						UPDATE_BALANCE_VAR0( *cur_y, delta1, cur_h[einfo->tail], cur_h[einfo->head] );
 						arcs->cap = arcs->r_cap = 0;
 						if ( delta < 0 ) // This may happen only for non-metric distances
 						{
@@ -280,7 +291,7 @@
 			
 			// Run max-flow and update the primal variables
 			//
-			Graph::flowtype max_flow = _graph -> run_maxflow(1);
+			Graph::flowtype max_flow = _graph -> maxflow<true>(1);
 			_APF -= (total_cap - max_flow);
 			if ( total_cap > max_flow )
 				_APF_change_time = _time;
@@ -433,7 +444,7 @@
 			// Run max-flow and update the primal variables
 			//
 			assert( _iter <= 1 );
-			Graph::flowtype max_flow = _graph -> apply_maxflow(1);
+			Graph::flowtype max_flow = _graph -> maxflow<false>(1);
 
 			double prev_APF = _APF;
 			for( i = 0; i < _numpoints; i++ )
@@ -538,7 +549,7 @@
 					if ( _nodes[i].tr_cap )
 					{
 						//assert(  _nodes[i].tr_cap < 0 );
-						_nodes[i].parent  = TERMINAL;
+						_nodes[i].parent  = FAST_PD_TERMINAL;
 						_nodes[i].is_sink = 1;
 						_nodes[i].DIST = 1;
 					}
@@ -653,7 +664,7 @@
 				if ( nd->tr_cap > 0 )
 				{
 					nd -> is_sink = 0;
-					nd -> parent = TERMINAL;
+					nd -> parent = FAST_PD_TERMINAL;
 					nd -> DIST = 1;
 
 					_graph->set_active(nd);
@@ -664,7 +675,7 @@
 				else if (nd->tr_cap < 0)
 				{
 					nd -> is_sink = 1;
-					nd -> parent = TERMINAL;
+					nd -> parent = FAST_PD_TERMINAL;
 					nd -> DIST = 1;
 				}
 				else nd -> parent = NULL;
@@ -679,7 +690,7 @@
 				if ( nd->tr_cap > 0 )
 				{
 					nd -> is_sink = 0;
-					nd -> parent = TERMINAL;
+					nd -> parent = FAST_PD_TERMINAL;
 					nd -> DIST = 1;
 
 					_graph->set_active(nd);
@@ -690,7 +701,7 @@
 				else if (nd->tr_cap < 0)
 				{
 					nd -> is_sink = 1;
-					nd -> parent = TERMINAL;
+					nd -> parent = FAST_PD_TERMINAL;
 					nd -> DIST = 1;
 				}
 				else nd -> parent = NULL;
@@ -703,7 +714,7 @@
 
 			// Run max-flow 
 			//
-			Graph::flowtype max_flow = _graph -> apply_maxflow(0);
+			Graph::flowtype max_flow = _graph -> maxflow<false>(0);
 
 			// Traverse source tree to update the primal variables 
 			//
@@ -712,7 +723,7 @@
 			for( i = source_nodes_start1; i >= 0; )
 			{
 				Graph::node *n = &_nodes[i];
-				if ( n->parent == TERMINAL )
+				if ( n->parent == FAST_PD_TERMINAL )
 				{
 					Node_info *pinfo = &_pinfo[i];
 
@@ -779,7 +790,7 @@
 			for( i = 0; i < num_children; i++ )
 			{
 				Graph::node *n = _children[i];
-				unsigned int id  = ((unsigned int)n - (unsigned int)_nodes) / sizeof(Graph::node); 
+				uintptr_t  id  = (reinterpret_cast<uintptr_t >(n) - reinterpret_cast<uintptr_t >(_nodes)) / sizeof(Graph::node);
 				Node_info *pinfo = &_pinfo[id];
 
 				// If necessary, repair "loads" in case of non-metric
@@ -942,10 +953,7 @@
 			}
 		}
 
-		double MAX( double a, double b ) { return ( a >= b ? a : b ); }
-		double MIN( double a, double b ) { return ( a <= b ? a : b ); }
-
-		static void err_fun(char * msg)
+		static void err_fun(const char * msg)
 		{
 			printf("%s",msg);
 		}
@@ -954,7 +962,7 @@
 		{
 			Graph::Label label; // current label
 			Real height; // active height of node
-			TIME time; // timestamp of change
+			short time; // timestamp of change
  			int next;    
 			int prev;
 			int *pairs; // neighboring edges
@@ -985,7 +993,7 @@
 		struct Pair_info
 		{
 			int i0, i1;
-			TIME time;
+			short time;
 		};
 
 		struct Arc_info
@@ -1003,12 +1011,19 @@
 		Graph::node **_children;
 		int          *_pairs_arr;
 
+		template<typename TLabel0, typename TLabel1>
+		Real DIST(TLabel0 l0, TLabel1 l1) {
+			return _dist[l1*_numlabels+l0];
+		}
+
         // Assignment or copying are not allowed
         //
         CV_Fast_PD( const CV_Fast_PD &other );
         CV_Fast_PD operator=( const CV_Fast_PD &other );
 };
 
+}
+
 #endif /* __FAST_PD_H__ */
 
 //#############################################################################
diff -urwB FastPD_DemoVersion/graph.h FastPD.src-patched/graph.h
--- FastPD_DemoVersion/graph.h	2009-02-24 16:10:08.000000000 -0500
+++ FastPD.src-patched/graph.h	2017-08-14 16:14:41.324044000 -0400
@@ -74,38 +74,34 @@
 	///////////////////////////////////////////////////
 */
 
-#ifndef __GRAPH_H__
-#define __GRAPH_H__
+#ifndef __FAST_PD_GRAPH_H__
+#define __FAST_PD_GRAPH_H__
 
-#include "block.h"
-#include "common.h"
+#include "opengm/inference/external/fastpd/block.h"
+
+namespace fastPDLib {
 
 /*
 	Nodes, arcs and pointers to nodes are
 	added in blocks for memory and time efficiency.
 	Below are numbers of items in blocks
 */
-#define NODE_BLOCK_SIZE 512
-#define ARC_BLOCK_SIZE 1024
-#define NODEPTR_BLOCK_SIZE 128
+const unsigned int NODE_BLOCK_SIZE = 512;
+const unsigned int ARC_BLOCK_SIZE = 1024;
+const unsigned int NODEPTR_BLOCK_SIZE = 128;
 
 /*
 	special constants for node->parent
 */
-#define TERMINAL ( (Graph::arc *) 1 )		/* to terminal */
-#define ORPHAN   ( (Graph::arc *) 2 )		/* orphan */
-
-#define INFINITE_D 1000000000		/* infinite distance to the terminal */
+#define FAST_PD_TERMINAL ( (Graph::arc *) 1 )		/* to terminal */
+#define FAST_PD_ORPHAN   ( (Graph::arc *) 2 )		/* orphan */
+#define FAST_PD_INFINITE_D 1000000000		/* infinite distance to the terminal */
 
 class Graph
 {
 public:
 
-#ifdef _MANY_LABELS_
-	typedef int Label;
-#else
-	typedef unsigned char Label;
-#endif
+	typedef FASTPDLABELVALUE Label;
 
 	typedef enum
 	{
@@ -115,42 +111,81 @@
 
 	/* Type of edge weights.
 	   Can be changed to char, int, float, double, ... */
-	typedef int Real;
+	typedef FASTPDENERGYVALUE Real;
 	typedef Real captype;
 
 	/* Type of total flow */
-	typedef int flowtype;
+	typedef Real flowtype;
 
 	typedef void * node_id;
 
 	/* interface functions */
 
-	/* Destructor */
-	~Graph();
-
 	/* Adds a node to the graph */
-	void add_nodes();
+	inline void add_nodes()
+	{
+		for( int i = 0; i < _num_nodes; i++ )
+		{
+			_nodes[i].first = NULL;
+			_nodes[i].tr_cap = 0;
+			_nodes[i].conflict_time = ushort(-1);
+		}
+	}
 
 	/* Adds a bidirectional edge between 'from' and 'to'
 	   with the weights 'cap' and 'rev_cap' */
-	void add_edges( int *pairs, int numpairs );
+	inline void add_edges( int *pairs, int numpairs )
+	{
+		captype cap = 0;
+		captype rev_cap = 0;
+		for( int i = 0; i < 2*numpairs; i+=2 )
+		{
+			node_id from = &_nodes[pairs[i]];
+			node_id to   = &_nodes[pairs[i+1]];
+			arc *a = &_arcs[i];
+			arc *a_rev = a + 1;
+			a -> sister = a_rev;
+			a_rev -> sister = a;
+			a -> next = ((node*)from) -> first;
+			((node*)from) -> first = a;
+			a_rev -> next = ((node*)to) -> first;
+			((node*)to) -> first = a_rev;
+			a -> head = (node*)to;
+			a_rev -> head = (node*)from;
+			a -> r_cap = cap;
+			a_rev -> r_cap = rev_cap;
+		}
+	}
 
 	/* Sets the weights of the edges 'SOURCE->i' and 'i->SINK'
 	   Can be called at most once for each node before any call to 'add_tweights'.
 	   Weights can be negative */
-	void set_tweights(node_id i, captype cap_source, captype cap_sink);
+	inline void set_tweights(node_id i, captype cap_source, captype cap_sink)
+	{
+		flow += (cap_source < cap_sink) ? cap_source : cap_sink;
+		((node*)i) -> tr_cap = cap_source - cap_sink;
+	}
 
 	/* Adds new edges 'SOURCE->i' and 'i->SINK' with corresponding weights
 	   Can be called multiple times for each node.
 	   Weights can be negative */
-	void add_tweights(node_id i, captype cap_source, captype cap_sink);
+	inline void add_tweights(node_id i, captype cap_source, captype cap_sink)
+	{
+		captype delta = ((node*)i) -> tr_cap;
+		if (delta > 0) cap_source += delta;
+		else           cap_sink   -= delta;
+		flow += (cap_source < cap_sink) ? cap_source : cap_sink;
+		((node*)i) -> tr_cap = cap_source - cap_sink;
+	}
 
 	/* After the maxflow is computed, this function returns to which
 	   segment the node 'i' belongs (Graph::SOURCE or Graph::SINK) */
-	termtype what_segment(node_id i);
+	inline termtype what_segment(node_id i)
+	{
+		if (((node*)i)->parent && !((node*)i)->is_sink) return SOURCE;
+		return SINK;
+	}
 
-	/* Computes the maxflow. Can be called only once. */
-	flowtype apply_maxflow( int track_source_nodes );
 
 /***********************************************************************/
 /***********************************************************************/
@@ -171,12 +205,9 @@
 		int				TS;			/* timestamp showing when DIST was computed */
 		int				DIST;		/* distance to the terminal */
 		short			is_sink;	/* flag showing whether the node is in the source or in the sink tree */
-
 		captype			tr_cap;		/* if tr_cap > 0 then tr_cap is residual capacity of the arc SOURCE->node
 									   otherwise         -tr_cap is residual capacity of the arc node->SINK */
-#ifndef _METRIC_DISTANCE_
-		TIME            conflict_time;
-#endif
+		ushort          conflict_time;
 	} node;
 
 	/* arc structure */
@@ -185,10 +216,8 @@
 		node_st			*head;		/* node q, i.e. node the arc points to */
 		arc_st			*next;		/* next arc with the same originating node */
 		arc_st			*sister;	/* arc qp, i.e. reverse arc */
-
 		captype			r_cap;		/* residual capacity */
-
-		Real            cap;        // cap_{pq}   
+		captype         cap;
 	} arc;
 
 	/* 'pointer to node' structure */
@@ -202,7 +231,7 @@
 	Block<arc>			*arc_block;
 	DBlock<nodeptr>		*nodeptr_block;
 
-	void	(*error_function)(char *);	/* this function is called if a error occurs,
+	void	(*error_function)(const char *);	/* this function is called if a error occurs,
 										   with a corresponding error message
 										   (or exit(1) is called if it's NULL) */
 
@@ -212,9 +241,16 @@
 	   function which will be called if an error occurs;
 	   an error message is passed to this function. If this
 	   argument is omitted, exit(1) will be called. */
-	Graph(node *nodes, arc *arcs, int num_nodes, void (*err_function)(char *) = NULL);
+	inline Graph(node *nodes, arc *arcs, int num_nodes, void (*err_function)(const char *) = NULL)
+	{
+		error_function = err_function;
+		_nodes = nodes;
+		_arcs  = arcs ;
+		_num_nodes = num_nodes;
+		flow = 0;
+	}
 
-	void Graph::reset_flow( void )
+	inline void reset_flow( void )
 	{
 		flow = 0;
 	}
@@ -233,9 +269,117 @@
 
 /***********************************************************************/
 
-	flowtype run_maxflow( int track_source_nodes );
-	void setup( void );
-	void do_augment(arc *middle_arc);
+	template<bool bORIG>
+	inline flowtype maxflow( int init_on )
+	{
+		node *i, *j, *current_node = NULL;
+		arc *a;
+		nodeptr *np, *np_next;
+		if(bORIG || init_on)
+			maxflow_init<bORIG>();
+		nodeptr_block = new DBlock<nodeptr>(NODEPTR_BLOCK_SIZE, error_function);
+		while ( 1 )
+		{
+			if ((i=current_node))
+			{
+				i -> next = NULL; /* remove active flag */
+				if (!i->parent) i = NULL;
+			}
+			if (!i)
+			{
+				if (!(i = next_active())) break;
+			}
+			/* growth */
+			if (!i->is_sink)
+			{
+				/* grow source tree */
+				for (a=i->first; a; a=a->next)
+				if (a->r_cap)
+				{
+					j = a -> head;
+					if (!j->parent)
+					{
+						j -> is_sink = 0;
+						j -> parent = a -> sister;
+						j -> TS = i -> TS;
+						j -> DIST = i -> DIST + 1;
+						set_active(j);
+					}
+					else if (j->is_sink) break;
+					else if (j->TS <= i->TS &&
+							 j->DIST > i->DIST)
+					{
+						/* heuristic - trying to make the distance from j to the source shorter */
+						j -> parent = a -> sister;
+						j -> TS = i -> TS;
+						j -> DIST = i -> DIST + 1;
+					}
+				}
+			}
+			else
+			{
+				if(bORIG)
+				{
+					/* grow sink tree */
+					for (a=i->first; a; a=a->next)
+					if (a->sister->r_cap)
+					{
+						j = a -> head;
+						if (!j->parent)
+						{
+							j -> is_sink = 1;
+							j -> parent = a -> sister;
+							j -> TS = i -> TS;
+							j -> DIST = i -> DIST + 1;
+							set_active(j);
+						}
+						else if (!j->is_sink) { a = a -> sister; break; }
+						else if (j->TS <= i->TS &&
+								 j->DIST > i->DIST)
+						{
+							/* heuristic - trying to make the distance from j to the sink shorter */
+							j -> parent = a -> sister;
+							j -> TS = i -> TS;
+							j -> DIST = i -> DIST + 1;
+						}
+					}
+				}
+				else
+				{
+					a = NULL;
+				}
+			}
+			TIME ++;
+			if (a)
+			{
+				i -> next = i; /* set active flag */
+				current_node = i;
+				/* augmentation */
+				augment<bORIG>(a);
+				/* augmentation end */
+				/* adoption */
+				while ((np=orphan_first))
+				{
+					np_next = np -> next;
+					np -> next = NULL;
+					while ((np=orphan_first))
+					{
+						orphan_first = np -> next;
+						i = np -> ptr;
+						nodeptr_block -> Delete(np);
+						if (!orphan_first) orphan_last = NULL;
+						if (i->is_sink) process_orphan<false>(i);
+						else            process_orphan<true>(i);
+					}
+					orphan_first = np_next;
+				}
+				/* adoption end */
+			}
+			else current_node = NULL;
+		}
+		delete nodeptr_block;
+		return flow;
+	}
 
 	/*
 	Functions for processing active list.
@@ -249,7 +393,7 @@
 	is empty, it is replaced by the second queue
 	(and the second queue becomes empty).
 	*/
-	inline void Graph::set_active(node *i)
+	inline void set_active(node *i)
 	{
 		if (!i->next)
 		{
@@ -260,12 +404,241 @@
 			i -> next = i;
 		}
 	}
-	node *next_active();
 
-	void maxflow_init();
-	void augment(arc *middle_arc);
-	void process_source_orphan(node *i);
-	void process_sink_orphan(node *i);
+	/*
+	Returns the next active node.
+	If it is connected to the sink, it stays in the list,
+	otherwise it is removed from the list
+	*/
+	inline node *next_active()
+	{
+		node *i;
+		while ( 1 )
+		{
+			if (!(i=queue_first[0]))
+			{
+				queue_first[0] = i = queue_first[1];
+				queue_last[0]  = queue_last[1];
+				queue_first[1] = NULL;
+				queue_last[1]  = NULL;
+				if (!i) return NULL;
+			}
+			/* remove it from the active list */
+			if (i->next == i) queue_first[0] = queue_last[0] = NULL;
+			else              queue_first[0] = i -> next;
+			i -> next = NULL;
+			/* a node in the list is active iff it has a parent */
+			if (i->parent) return i;
+		}
+	}
+
+	template<bool bORIG>
+	inline void maxflow_init() {
+		node *i;
+		queue_first[0] = queue_last[0] = NULL;
+		queue_first[1] = queue_last[1] = NULL;
+		orphan_first = NULL;
+		int k;
+		for( k = 0, i = _nodes; k < _num_nodes; k++, i++ )
+		{
+			i -> next = NULL;
+			i -> TS = 0;
+			if (i->tr_cap > 0)
+			{
+				/* i is connected to the source */
+				i -> is_sink = 0;
+				i -> parent = FAST_PD_TERMINAL;
+				set_active(i);
+				i -> TS = 0;
+				i -> DIST = 1;
+			}
+			else if (i->tr_cap < 0)
+			{
+				/* i is connected to the sink */
+				i -> is_sink = 1;
+				i -> parent = FAST_PD_TERMINAL;
+				if(bORIG)
+					set_active(i);
+				i -> TS = 0;
+				i -> DIST = 1;
+			}
+			else
+			{
+				i -> parent = NULL;
+			}
+		}
+		TIME = 0;
+	}
+
+	inline void set_orphan_front(node *i)
+	{
+		nodeptr *np;
+		i -> parent = FAST_PD_ORPHAN;
+		np = nodeptr_block -> New();
+		np -> ptr = i;
+		np -> next = orphan_first;
+		orphan_first = np;
+	}
+
+	template<bool bORIG>
+	inline void augment(arc *middle_arc)
+	{
+		node *i;
+		arc *a;
+		captype bottleneck;
+		/* 1. Finding bottleneck capacity */
+		/* 1a - the source tree */
+		bottleneck = middle_arc -> r_cap;
+		for (i=middle_arc->sister->head; ; i=a->head)
+		{
+			a = i -> parent;
+			if (a == FAST_PD_TERMINAL) break;
+			if (bottleneck > a->sister->r_cap) bottleneck = a -> sister -> r_cap;
+		}
+		if (bottleneck > i->tr_cap) bottleneck = i -> tr_cap;
+		/* 1b - the sink tree */
+		for (i=middle_arc->head; ; i=a->head)
+		{
+			a = i -> parent;
+			if (a == FAST_PD_TERMINAL) break;
+			if (bottleneck > a->r_cap) bottleneck = a -> r_cap;
+		}
+		if (bottleneck > - i->tr_cap) bottleneck = - i -> tr_cap;
+		/* 2. Augmenting */
+		/* 2a - the source tree */
+		middle_arc -> sister -> r_cap += bottleneck;
+		middle_arc -> r_cap -= bottleneck;
+		for (i=middle_arc->sister->head; ; i=a->head)
+		{
+			a = i -> parent;
+			if (a == FAST_PD_TERMINAL) break;
+			a -> r_cap += bottleneck;
+			a -> sister -> r_cap -= bottleneck;
+			if (!a->sister->r_cap)
+			{
+				/* add i to the adoption list */
+				set_orphan_front(i);
+			}
+		}
+		i -> tr_cap -= bottleneck;
+		if (!i->tr_cap)
+		{
+			/* add i to the adoption list */
+			set_orphan_front(i);
+		}
+		/* 2b - the sink tree */
+		for (i=middle_arc->head; ; i=a->head)
+		{
+			a = i -> parent;
+			if (a == FAST_PD_TERMINAL) break;
+			a -> sister -> r_cap += bottleneck;
+			a -> r_cap -= bottleneck;
+			if (!a->r_cap)
+			{
+				/* add i to the adoption list */
+				set_orphan_front(i);
+			}
+		}
+		i -> tr_cap += bottleneck;
+		if (!i->tr_cap)
+		{
+			if(bORIG)
+			{
+				/* add i to the adoption list */
+				set_orphan_front(i);
+			}
+			else
+			{
+				i->parent = NULL;
+			}
+		}
+		flow += bottleneck;
+	}
+
+	template<bool bSOURCE>
+	inline void process_orphan(node *i)
+	{
+		node *j;
+		arc *a0, *a0_min = NULL, *a;
+		int d, d_min = FAST_PD_INFINITE_D;
+		/* trying to find a new parent */
+		for (a0=i->first; a0; a0=a0->next)
+		if (bSOURCE?(a0->sister->r_cap):(a0->r_cap))
+		{
+			j = a0 -> head;
+			if ((bSOURCE?(!j->is_sink):(j->is_sink)) && (a=j->parent))
+			{
+				/* checking the origin of j */
+				d = 0;
+				while ( 1 )
+				{
+					if (j->TS == TIME)
+					{
+						d += j -> DIST;
+						break;
+					}
+					a = j -> parent;
+					d ++;
+					if (a==FAST_PD_TERMINAL)
+					{
+						j -> TS = TIME;
+						j -> DIST = 1;
+						break;
+					}
+					if (a==FAST_PD_ORPHAN) { d = FAST_PD_INFINITE_D; break; }
+					j = a -> head;
+				}
+				if (d<FAST_PD_INFINITE_D) /* j originates from the terminal - done */
+				{
+					if (d<d_min)
+					{
+						a0_min = a0;
+						d_min = d;
+					}
+					/* set marks along the path */
+					for (j=a0->head; j->TS!=TIME; j=j->parent->head)
+					{
+						j -> TS = TIME;
+						j -> DIST = d --;
+					}
+				}
+			}
+		}
+		if ((i->parent = a0_min))
+		{
+			i -> TS = TIME;
+			i -> DIST = d_min + 1;
+		}
+		else
+		{
+			/* no parent is found */
+			i -> TS = 0;
+
+			/* process neighbors */
+			for (a0=i->first; a0; a0=a0->next)
+			{
+				j = a0 -> head;
+				if ((bSOURCE?(!j->is_sink):(j->is_sink)) && (a=j->parent))
+				{
+					if (bSOURCE?(a0->sister->r_cap):(a0->r_cap)) set_active(j);
+					if (a!=FAST_PD_TERMINAL && a!=FAST_PD_ORPHAN && a->head==i)
+					{
+						/* add j to the adoption list */
+						nodeptr *np;
+						j -> parent = FAST_PD_ORPHAN;
+						np = nodeptr_block -> New();
+						np -> ptr = j;
+						if (orphan_last) orphan_last -> next = np;
+						else             orphan_first        = np;
+						orphan_last = np;
+						np -> next = NULL;
+					}
+				}
+			}
+		}
+	}
 };
 
+}
+
 #endif
